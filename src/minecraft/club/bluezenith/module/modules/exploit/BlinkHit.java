package club.bluezenith.module.modules.exploit;

import club.bluezenith.events.Listener;
import club.bluezenith.events.impl.PacketEvent;
import club.bluezenith.module.Module;
import club.bluezenith.module.value.types.IntegerValue;
import club.bluezenith.util.client.MillisTimer;
import club.bluezenith.util.player.PacketUtil;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.network.EnumPacketDirection;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C02PacketUseEntity;

import java.util.ArrayList;

import static club.bluezenith.module.ModuleCategory.EXPLOIT;
import static net.minecraft.network.play.client.C02PacketUseEntity.Action.ATTACK;

public class BlinkHit extends Module {
    private final ArrayList<Packet<?>> packets = new ArrayList<Packet<?>>();
    private final IntegerValue maxtime = new IntegerValue("max time", 500, 1, 2000, 1, true, null).setIndex(1);
    private final MillisTimer timer = new MillisTimer();

    public BlinkHit() {
        super("BlinkHit", EXPLOIT);
    }

    @Listener
    public void onPacket(PacketEvent e) {
        if (mc.thePlayer == null) return;
        if (e.direction == EnumPacketDirection.SERVERBOUND || mc.isSingleplayer()) return;

        if (e.packet instanceof C02PacketUseEntity) {
            final C02PacketUseEntity lx = (C02PacketUseEntity) e.packet;
            final EntityLivingBase target = (EntityLivingBase) lx.getEntityFromWorld(mc.theWorld);
            if (lx.getAction() == ATTACK && target.hurtTime <= 1) {
                if (!packets.isEmpty()) {
                    final Packet<?>[] p = packets.toArray(new Packet[0]);
                    for (Packet<?> packet : p) {
                        PacketUtil.sendSilent(packet);
                    }
                    packets.clear();
                }
            }
            timer.reset();
        }
        else if (timer.hasTimeReached(maxtime.get())) {
            if (!packets.isEmpty()) {
                final Packet<?>[] p = packets.toArray(new Packet[0]);
                for (Packet<?> packet : p) {
                    PacketUtil.sendSilent(packet);
                }
                packets.clear();
            }
            timer.reset();
        }
        else {
            e.cancel();
            packets.add(e.packet);
        }
    }

    @Override
    public void onEnable() {
        packets.clear();
    }

    @Override
    public void onDisable() {
        if (!packets.isEmpty()) {
            final Packet<?>[] p = packets.toArray(new Packet[0]);
            for (Packet<?> packet : p) {
                PacketUtil.sendSilent(packet);
            }
            packets.clear();
        }
    }
}
