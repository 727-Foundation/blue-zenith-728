package club.bluezenith.module.modules.exploit;

import club.bluezenith.BlueZenith;
import club.bluezenith.events.Listener;
import club.bluezenith.events.impl.UpdatePlayerEvent;
import club.bluezenith.module.Module;
import club.bluezenith.module.ModuleCategory;
import club.bluezenith.module.value.types.BooleanValue;
import club.bluezenith.module.value.types.IntegerValue;
import club.bluezenith.module.value.types.ModeValue;
import club.bluezenith.util.math.AStarCustomPathFinder;
import club.bluezenith.util.player.PacketUtil;
import club.bluezenith.util.player.PlayerUtil;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.util.MovingObjectPosition;
import net.minecraft.util.Vec3;
import org.lwjgl.input.Mouse;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static org.lwjgl.input.Keyboard.KEY_LSHIFT;
import static org.lwjgl.input.Keyboard.isKeyDown;
import static org.lwjgl.input.Mouse.isButtonDown;

public class ClickTP extends Module {

    private final ModeValue mode = new ModeValue("Teleport", "On Click", "On Click", "On Toggle").setIndex(1);
    private final ModeValue key = new ModeValue("Mouse button", "Left", "Left", "Middle", "Right").setIndex(2).showIf(() -> mode.is("On Click"));
    private final BooleanValue spoofGround = new BooleanValue("Spoof Ground", false).setIndex(3);
    private final BooleanValue requireSneak = new BooleanValue("Require Sneak", false).setIndex(4).showIf(() -> !mode.is("On Toggle"));
    private final BooleanValue damage = new BooleanValue("Self-Damage", false).setIndex(5);
    private final ModeValue tpMode = new ModeValue("Mode", "Instant", "Instant", "Gradual").setIndex(6);
    private final IntegerValue gradualDelay = new IntegerValue("Packet Delay", 5, 5, 150, 5).setIndex(7).showIf(() -> tpMode.is("Gradual"));
    private final IntegerValue step = new IntegerValue("Step", 0, 0, 8, 1).setIndex(8);
    private final ModeValue pathfinder = new ModeValue("Pathfinding", "Smart", "Smart", "Linear").setIndex(9);
    private final BooleanValue Yposworkaround = new BooleanValue("Fix Y", true).setIndex(10).showIf(() -> pathfinder.is("Linear"));

    public ClickTP() {
        super("ClickTP", ModuleCategory.EXPLOIT);
    }

    boolean pressed;

    @Listener
    public void onUpdate(UpdatePlayerEvent event) {
        if(event.isPre()) {
            if (Mouse.isButtonDown(getMouseKey()) && allowSneak() || mode.is("On Toggle")) {
                if(pressed) return;
                if(mode.is("On Toggle")) {
                    this.toggle();
                }
                pressed = true;
                final Vec3 origin = player.getLookVec();
                final Vec3 expanded = new Vec3(origin.xCoord * 300, origin.yCoord * 300, origin.zCoord * 300);
                final Vec3 position = new Vec3(player.posX, player.posY + 1, player.posZ);

                final MovingObjectPosition result = world.rayTraceBlocks(position, position.add(expanded), false);
                if (result != null && result.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK && mc.currentScreen == null) {
                    if (pathfinder.is("Smart")) {
                        final AStarCustomPathFinder finder = new AStarCustomPathFinder(position, result.hitVec);
                        finder.compute(1000, 8);
                        AtomicInteger sent = new AtomicInteger();
                        List<Vec3> path = finder.getPath();
                        AtomicReference<Double> serverX = new AtomicReference<>((double) 0);
                        AtomicReference<Double> serverY = new AtomicReference<>((double) 0);
                        AtomicReference<Double> serverZ = new AtomicReference<>((double) 0);
                        AtomicInteger entries = new AtomicInteger();
                        path = path.stream().filter(new Predicate<Vec3>() {
                                                        @Override
                                                        public boolean test(Vec3 p) {
                                entries.getAndIncrement();
                            if (entries.get() == 1) {
                                serverX.set(p.xCoord);
                                serverY.set(p.yCoord);
                                serverZ.set(p.zCoord);
                                return true;
                            } else {
                                double x = p.xCoord - serverX.get();
                                double y = p.yCoord - serverY.get();
                                double z = p.zCoord - serverZ.get();
                                return (x * x + y * y + z * z >= step.get());
                            }
                        }}).collect(Collectors.toList());
                        List<Vec3> finalPath = path;
                        if (damage.get()) PlayerUtil.damageNormal((float) 3.004);
                        AtomicInteger pDelay = new AtomicInteger();
                        for (Vec3 p : path) {
                            BlueZenith.scheduledExecutorService.schedule(new Runnable() {
                                @Override
                                public void run() {
                            double pos = spoofGround.get() ? Math.round(p.yCoord + 1) : p.yCoord;
                                PacketUtil.sendSilent(new C03PacketPlayer.C04PacketPlayerPosition(p.xCoord, pos, p.zCoord, spoofGround.get()));
                                if (sent.incrementAndGet() >= finalPath.size() - 1) {
                                    mc.thePlayer.setPosition(result.hitVec.xCoord, result.hitVec.yCoord + 1, result.hitVec.zCoord);
                                }
                            }}, pDelay.addAndGet(tpMode.is("Gradual") ? gradualDelay.get() : 1), TimeUnit.MILLISECONDS);
                        }
                    }
                    else {
                        final double dist = position.distanceTo(result.hitVec);
                        Vec3 diff = result.hitVec.subtract(position);
                        final ArrayList<Vec3> path = new ArrayList<>();
                        if (Yposworkaround.get() && position.yCoord < result.hitVec.yCoord) {
                            path.add(new Vec3(position.xCoord, result.hitVec.yCoord, position.zCoord));
                            position.yCoord = result.hitVec.yCoord;
                        }
                        final double fragments = Math.ceil(dist / 7);
                        for (int i = 1; i < fragments + 1; i++) {
                            path.add(position.add(diff.multiply(i * (1 / fragments), i * (1 / fragments), i * (1 / fragments))));
                        }

                        AtomicInteger sent = new AtomicInteger();
                        AtomicInteger pDelay = new AtomicInteger();
                        for (Vec3 p : path) {
                            BlueZenith.scheduledExecutorService.schedule(new Runnable() {
                                @Override
                                public void run() {
                                double pos = spoofGround.get() ? Math.round(p.yCoord + 1) : p.yCoord;
                                PacketUtil.sendSilent(new C03PacketPlayer.C04PacketPlayerPosition(p.xCoord, pos, p.zCoord, spoofGround.get()));
                                if (sent.incrementAndGet() >= path.size() - 1) {
                                    mc.thePlayer.setPosition(result.hitVec.xCoord, result.hitVec.yCoord + 1, result.hitVec.zCoord);
                                }
                            }}, pDelay.addAndGet(tpMode.is("Gradual") ? gradualDelay.get() : 1), TimeUnit.MILLISECONDS);
                        }
                    }
                }
            }
        }
        if(event.isPre() && !isButtonDown(getMouseKey()))
            pressed = false;
    }

    int getMouseKey() {
        switch (key.get()) {
            case "Left":
                return 0;
            case "Right":
                return 1;
            case "Middle":
                return 2;
        }
        return 0;
    }

    boolean allowSneak() {
        return !requireSneak.get() || isKeyDown(KEY_LSHIFT);
    }
}