package club.bluezenith.module.modules.exploit;

import club.bluezenith.events.Listener;
import club.bluezenith.events.impl.PacketEvent;
import club.bluezenith.events.impl.SpawnPlayerEvent;
import club.bluezenith.events.impl.UpdatePlayerEvent;
import club.bluezenith.module.Module;
import club.bluezenith.module.value.types.BooleanValue;
import club.bluezenith.module.value.types.IntegerValue;
import club.bluezenith.module.value.types.ListValue;
import club.bluezenith.util.player.PacketUtil;
import com.google.common.collect.Lists;
import net.minecraft.moved.sussy.C00Handshake;
import net.minecraft.network.Packet;
import net.minecraft.network.login.client.C00PacketLoginStart;
import net.minecraft.network.login.client.C01PacketEncryptionResponse;
import net.minecraft.network.play.client.C00PacketKeepAlive;
import net.minecraft.network.play.client.C0FPacketConfirmTransaction;
import net.minecraft.network.status.client.C00PacketServerQuery;
import net.minecraft.network.status.client.C01PacketPing;

import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import static club.bluezenith.module.ModuleCategory.EXPLOIT;
import static club.bluezenith.util.math.MathUtil.getRandomInt;
import static club.bluezenith.util.player.PacketUtil.sendSilent;
import static java.lang.Math.min;
import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;
import static net.minecraft.network.EnumPacketDirection.SERVERBOUND;

public class PingSpoof extends Module {
    private final static ScheduledExecutorService service = newSingleThreadScheduledExecutor();
    private final static List<PacketTask> tasks = Lists.newArrayList();
    private int currentPing = 0;

    private final BooleanValue captureAll = new BooleanValue("Capture all packets", false).setIndex(1);
    private final ListValue packets = new ListValue("Packets", "C0F", "C00").setIndex(2).showIf(() -> !captureAll.get());
    private final BooleanValue normalize = new BooleanValue("Normalize ping", true).setIndex(3).showIf(() -> !captureAll.get() && packets.getSelectedOptions().size() > 1);
    private final BooleanValue shuffle = new BooleanValue("Random order", false).setIndex(4).showIf(() -> packets.getSelectedOptions().size() > 1 || captureAll.get());
    private final BooleanValue increment = new BooleanValue("Increase over time", false).setIndex(5).showIf(() -> !captureAll.get() && packets.getSelectedOptions().size() > 1);
    private final IntegerValue start = new IntegerValue("Start delay", 200, 200, 8000, 50).setIndex(6).showIf(() -> increment.isVisible() && increment.get());
    private final IntegerValue incrementAmount = new IntegerValue("Increment", 50, 10, 500, 10).setIndex(7).showIf(() -> increment.isVisible() && increment.get());
    public final IntegerValue minDelay = new IntegerValue("Min delay", 200, 50, 15000, 50).setIndex(8)
            .setValueChangeListener((pre, post) -> {
               if(getMax().isVisible() && post > getMax().get()) return pre;
               else return post;
            });
    private final IntegerValue maxDelay = new IntegerValue("Max delay", 200, 50, 15000, 50).setIndex(9).showIf(() -> shuffle.isVisible() && shuffle.get())
            .setValueChangeListener((pre, post) -> {
                if(pre < getMin().get()) {
                    getMin().set(pre);
                }
                if(post < getMin().get()) return pre;
                else return post;
            });

    public PingSpoof() {
        super("PingSpoof", EXPLOIT);
    }

    @Listener
    public void onPacket(PacketEvent event) {
        if(mc.isSingleplayer() || event.direction == SERVERBOUND) return;

        final Packet<?> p = event.packet;

        if(this.captureAll.get()) {
            if(p instanceof C00PacketServerQuery
                    || p instanceof C00PacketLoginStart
                    || p instanceof C00Handshake
                    || p instanceof C01PacketPing
                    || p instanceof C01PacketEncryptionResponse) return;

            tasks.add(new PacketTask(p, service.schedule(() -> sendSilent(p), this.currentPing, TimeUnit.MILLISECONDS)));
            event.cancel();
            this.increase();
        } else {
            if(p instanceof C00PacketKeepAlive && this.packets.getOptionState("C00")) {
                tasks.add(new PacketTask(p, service.schedule(() -> sendSilent(p), this.currentPing, TimeUnit.MILLISECONDS)));
                this.increase();
                event.cancel();
            } else if(p instanceof C0FPacketConfirmTransaction && this.packets.getOptionState("C0F")) {
                tasks.add(new PacketTask(p, service.schedule(() -> sendSilent(p), this.currentPing, TimeUnit.MILLISECONDS)));
                if(!this.normalize.get() || !this.packets.getOptionState("C00"))
                    this.increase();
                event.cancel();
                //ClientUtils.debug(this.currentPing);
            }
        }
    }

    @Listener
    @SuppressWarnings("unused")
    public void onSpawn(SpawnPlayerEvent event) {
        this.currentPing = this.increment.get() ? this.start.get() : this.minDelay.get();
        tasks.forEach(PacketTask::cancel);
        tasks.clear();
    }

    IntegerValue getMin() {
        return minDelay;
    }

    IntegerValue getMax() {
        return maxDelay;
    }

    void increase() {
        if(increment.get() && increment.isVisible()) {
            this.currentPing = min(getRandomInt(this.currentPing + this.incrementAmount.get() / 2, this.currentPing + this.incrementAmount.get()), this.maxDelay.get());
        } else if(shuffle.get()) {
            this.currentPing = getRandomInt(this.minDelay.get(), this.maxDelay.get());
        } else this.currentPing = this.minDelay.get();
    }

    @Listener
    public void onUpdate(UpdatePlayerEvent e) {
        if (e.isPre() && player.ticksExisted % 20 == 0) {
            tasks.removeIf(task -> task.scheduledFuture.isCancelled() || task.scheduledFuture.isDone());
        }
    }


    @Override
    public void onDisable() {
        this.currentPing = 0;
        tasks.stream().filter(task -> !task.scheduledFuture.isDone()).forEach(task -> {
            PacketUtil.sendSilent(task.packet);
            task.cancel();
        });
        tasks.clear();
    }

    private static class PacketTask {
        final Packet<?> packet;
        final ScheduledFuture<?> scheduledFuture;

        PacketTask(Packet<?> packet, ScheduledFuture<?> scheduledFuture) {
            this.packet = packet;
            this.scheduledFuture = scheduledFuture;
        }

        void cancel() {
            scheduledFuture.cancel(true);
        }
    }

}
